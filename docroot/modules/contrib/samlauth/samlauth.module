<?php

/**
 * @file
 * Allows users to authenticate against an external SAML identity provider.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\Component\Utility\UrlHelper;
use Drupal\samlauth\Controller\SamlController;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\user\UserInterface;

/**
 * Implements hook_help().
 */
function samlauth_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the samlauth module.
    case 'help.page.samlauth':
      $module_path = \Drupal::moduleHandler()->getModule('samlauth')->getPath();
      $output = '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Allows users to authenticate against an external SAML identity provider.') . '</p>';
      $output .= '<p>' . t('Most information on how to configure this module is in the <a href=":url">README.md file</a>.', [':url' => Url::fromUri("base:$module_path/README.md")->toString()]) . '</p>';
      return $output;
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for the user edit form.
 */
function samlauth_form_user_form_alter(&$form, FormStateInterface $form_state) {
  // Only affect SAML-linked users without the 'bypass' permission; see also
  // samlauth_check_saml_user().
  /** @var \Drupal\user\Entity\User $account */
  $account = $form_state->getBuildInfo()['callback_object']->getEntity();
  if ($account->id() == \Drupal::currentUser()->id() && !$account->hasPermission('bypass saml login')) {
    /** @var \Drupal\externalauth\AuthmapInterface $authmap */
    $authmap = \Drupal::service('externalauth.authmap');
    if ($authmap->get($account->id(), 'samlauth')) {
      // Hide the change password field, because the password has no function
      // for users who cannot log in directly.
      $form['account']['pass']['#access'] = FALSE;
      // Also lock the e-mail field. We could leave it as-is because the user
      // is very likely to not know their current password and therefore unable
      // to change the e-mail anyway. Locking the field and removing the
      // "current password" field just makes things more understandable for the
      // average user. (This is the '>80% use case'; it is actually possible
      // for a user whose account was created locally and linked to a SAML
      // login afterwards, to know their password. If not being able to change
      // their e-mail is a concern, then this needs to be solved by role /
      // permission tweaking, by custom code or by an issue in the samlauth
      // module queue that makes a clear case for solving this in a general
      // manner.)
      $form['account']['mail']['#disabled'] = TRUE;
      $form['account']['current_pass']['#access'] = FALSE;

      $form['account']['saml_notice'] = [
        '#markup' => t('<strong>NOTE:</strong> E-mail address and password are controlled via SAML.'),
        '#weight' => -1,
      ];
      $url = \Drupal::config(SamlController::CONFIG_OBJECT_NAME)
        ->get('idp_change_password_service');
      if ($url && UrlHelper::isValid($url, TRUE)) {
        $form['account']['saml_notice']['#markup'] .= ' '
          . t('Please visit <a href="@link">this link</a> to change.', ['@link' => $url]);
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for the login form.
 */
function samlauth_form_user_login_form_alter(&$form, FormStateInterface $form_state) {
  $form['#validate'][] = 'samlauth_check_saml_user';
}

/**
 * Validation callback for SAML users logging in through the normal methods.
 */
function samlauth_check_saml_user($form, FormStateInterface $form_state) {
  // If previous validation has already failed (name/pw incorrect or blocked),
  // bail out so we don't disclose any details about a user that otherwise
  // wouldn't be authenticated. Also skip unworkable form state.
  if (!$form_state->hasAnyErrors() && $form_state->hasValue('name')) {
    // If the user has logged into the site using samlauth before, block them
    // depending on a permission. (There is no option to disallow _any_ user
    // without that permission from logging in locally; that's not considered
    // the business of this module.)
    /** @var \Drupal\user\Entity\User $account */
    $account = user_load_by_name($form_state->getValue('name'));
    if (!$account) {
      $form_state->setErrorByName('name', t('Could not load user to do a validation check.'));
    }
    elseif (!$account->hasPermission('bypass saml login')) {
      /** @var \Drupal\externalauth\AuthmapInterface $authmap */
      $authmap = \Drupal::service('externalauth.authmap');
      if ($authmap->get($account->id(), 'samlauth')) {
        $form_state->setErrorByName('name', t('This user is only allowed to log in through an external authentication provider.'));
      }
    }
  }
}

/**
 * Implements hook_user_presave().
 */
function samlauth_user_presave(UserInterface $account) {
  static $recursion_detection = FALSE;
  // Synchronize user attributes for a new user before saving an account
  // (instead of subscribing to the externalauth.register event), so we don't
  // need to save the new user a second time to add our SAML attribute values.
  // This also means that if attribute synchronization throws an exception, we
  // don't end up with a half baked user saved in the database.
  if (!$recursion_detection && $account->isNew()) {
    // Check that we're processing a valid ACS request, by checking the user
    // name attribute in the OneLogin'Saml2\Auth object. Note we get the
    // SamlService and construct a OneLogin\Saml2\Auth object on every first
    // user save in a request, which is not ideal but not too wasteful since
    // user saves don't happen often.
    /** @var \Drupal\samlauth\SamlService $saml_service */
    $saml_service = \Drupal::service('samlauth.saml');
    if ($saml_service->getAttributeByConfig('user_name_attribute')) {
      // This code assumes that the first save operation of a new user is
      // connected to SAML attributes found in a request. That's a safe bet;
      // those attributes are really only set if a SAML response was just
      // processed and validated by the ACS. No other code can come in between
      // processing that request and saving a new user. (If a
      // externalauth.authmap_alter or samlauth.user_link event feels the need
      // to independently create and save a user... we have bigger issues.) A
      // samlauth.user_sync event listener, which we will dispatch now, could
      // accidentally call user_save() again on this account... which is why we
      // implement $recursion_detection.
      $recursion_detection = TRUE;
      $saml_service->synchronizeUserAttributes($account, TRUE);
    }
  }
}
